# a0

### Part 1: Route Pichu

##### Issues with starter code
The starter code provided by the instructors was very helpful as a place to start, but I quickly realized that it wasn't perfect. The search algorithm would constantly get caught in a loop and continue running without end. To help me debug where the issue was, I added several print statements (even though I am sure there are better ways to debug code!) in order to see what the fringe looked like as the algorithm progressed. I noticed that it kept getting caught in a loop whenever it encountered a "dead end," that is, a cell that has no choice but to backtrack and return to the cell it just came from. This helped me uncover the main issue with the starter code. Since there was no record of where the search had already been, whenever it got to a point where it would be forced to backtrack and return to a cell it just came from, it would simply return to the dead end once again and thus the never ending cycle would start. 

##### My solution
To help prevent the never ending loops, the first thing I did was add a list of places that been visited already so that I could quickly eliminate any cell that had already been explored when the move() function was called. After that change, if the algorithm began to search down a dead end, as soon as it hit the end it would no longer see moving backwards as a valid move and would be force to serach elsewhere in the fringe. Once I had that issue fixed, I began trying to improve the efficiency of the search. The starter code had implemented depth first search, but I instead chose to implement A* search because it can improve the time complexity of the search. For the heuristic function I decided to choose the Euclidian distance from the next cell being explored to the target. I wrote a simple helper function that computed the distance between to sets of coordinates and then also created a simple formula that would scan the map to find the location of the target. 

The other main component of the A* implementation is the idea of the priority queue for storing the fringe. First, to the fringe I added several additional elements to each potential move on the board, the total distance travelled so far, as well as the sum of the distance travelled and the heuristic function. Then I created a helper funtion that would search through the list of elements in the fringe and calculate the index of the "move" with the lowest combined distance and pop this element. 

With the heuristic function and the priority queue all set, the final step was to keep track of the directions that had been travelled up to that point. In order to accomplish this I wrote one more helper function that would take two sets of coordinates and return the direction travelled from the first set to the second. I also added an empty list to each element in the fringe so that I could keep track of all the states that had been searched through so far.

With the pieces all in place, I put everything together into the new and improved search1() function. As soon as the goal state is reached, the total distance as well as the list of directions gets returned. The final step was to take care of the case when there was no solution. To accomplish this, I added a line to the code that says if the length of the fringe is ever 0 when it gets checked, which means the entire search space has been explored and there is no solution, return 'Inf'

##### Assumptions
Some of the assumptions I am making in this solution is that a bird can only fly vertically or horizontally, and not diagonally. Second, I am assuming the shape of the map is rectangular in shape. This assumptions comes into play with the successor function checks for valid moves. If the map was somehow curved, my solution would most likely produce incorrect results, or at least be slower than it could be. 

### Part 2: Arrange Pichu

##### Issues with starter code
The starter code was actually very close to working correctly. The big issue that it had was that it didn't take into consideration whether two pichus could "see" each other. 

##### My solution
The main thing I added to the code was a new function that would search up/down/left/right to see whether a pichu could be seen from a given spot. If it could, then that spot would not be considered as a valid spot by the successor function and a new board with a pichu at that spot would not be explored. Even with just this one relatively small change, the program works as intended. When a solution exists, it can generally find it within milliseconds (at least for the sample map given to us). When it starts to run into the solutions that dont exist, i.e. when K gets too large, it does take a while to realize that a soltuion is impossible. This is becuase it needs to search through the entire state space in order to ensure that a solution does not exist. 

I decided to stick with the depth first search implementation that existed in the starter code since the program seemed to find a solution whenever I tested it and could do so pretty quickly. The state space that gets searched through is all the possible iterations of the given map that contain between 1 and K pichus. The initial state is a map with 1 pichu. The successor function returns a list of possible board states that have one more pichu added in a valid spot, i.e. a spot where the new pichu cannot see any of the current pichus. For this abstraction there doesn't seem to be a natural cost function. As long as a solution is found, there isn't one that would be "better" than another

### Extra Credit

##### New additions
The first thing that I had to do to tackle the extra credit assignment was to expand the valid_state() function to also look to see if two pichus could see each other diagonally. My first thought was to create an entirely separate function that could be called if K turned out to be 0, and would be ignored if K were greater than 0 (in which case the original valid_spot() function would run). This decision caused me to have to then create several more modified functions, namely super_successors(), is_super_goal(), and super_search() as well as modified verison of solve(). I also pulled out the main code that was held within solve() and made it it's own function standard_search(). Before the resubmission deadline I plan on trying to combine everything into singular functions that can handle either case, but it's late, and the deadline is approaching. TFor K = 0. the solve() function also needed to be modified to run through multiple iterations of "supser search" (which is identical to standard_search() except it uses the stricter criteria for placing the pichus) until it couldn't find a solution. As soon as this happened, the functions decreases K, or in my case i, by 1 and runs the result of the last run of super_search().

